Структура проекта:

- `css/` — стили
- `doc/` — заметки и проектная документация
- `lib/` — библиотеки (в т.ч. сторонние, например, require.js)
- `src/` — исходники
- `tests/` — юнит-тесты


# TODO:

- [ ] Продумать стратегии выполнения и архитектуру run process'а (ниже приложу выдержку из телеграмма). Самый важный пункт. Запилить после этого TODO
- [ ] Tape (рабочее название, можно поменять). В model создать класс, реализующий ленту.
- [ ] class Diagram Part от которого наследуются Element и Line. Это пока под вопросом.

## Из телеграмма

```
Есть некоторый альфа-класс, внутри которого находятся экземпляры трех 
других классов. Примерные названия этих 3 классов (в общем то не 
названия, просто пока обозначили, чтобы понимать, о чем речь): 
*RunProcess;
*UI;
*Strategy;

Strategy занимается тем, что контролирует режим выполнения. Диаграмма может выполняться пошагово или с разной скоростью,
некоторые сабдиаграммы, можно будет не показывать (см. Предложения в docs) и т.д. Вот этот парень говорит всем как и с какой
скоростью выполняться. По сути, на самом примитивном уровне он должен уметь вызывать метод doStep() из RunProcess и потом метод
отрисовки из UI. Также, именно в Strategy лежат методы start() и stop(), которые начинают выполнение.

Как уже, наверное, понятно, RunProcess реализует, собственно, логику машины Тьюринга. У него есть основной метод doStep() который
выполняет следующий элемент текущей диаграммы. Также где-то нужно будет хранить стек вызова сабдиаграмм, вероятно, где-то там.
Стек - обычный такой, классический стек, как в ассемблере. Сделаем с помошью массива и его стандартных методов. Еще нужно будет
хранить состояние или вроде того, но тут уже нужно глубже продумывать архитектуру.

UI на самом деле пока продумывать особо смысла нет. Мы просто знаем, что он есть и что он делает что-то с графоном. Как именно,
какую часть отрисовки берет он на себя и т.д. не известно. Вполне вероятно, что часть отрисовки лучше будет засунуть в методы
классов, которые лежат в model. По крайней мере, научить Tape самостоятельно себя рисовать - идея, вроде, здравая, хотя и не
панацея.
```

## Наработки по RunProcess
(Кстати, может переименовать в Worker или вроде того?)
### Вариант первый, монолитный
1) У него должен быть конструктор, который получает экземляр ленты с уже заполнеными данными и результат работы парсера.
  В итоге в классе есть projectPackage (это от парсера), tape (лента с данными), currentDiagram - ссылка на текущую диаграмму
  (в начале - main), currentElement - ссылка на текущий элемент (в начале - enter).

2) Вся информация о ленте (позиция, текущая буква) хранится в tape и возвращается ее методами.
 Также осуществляется перемещене по ней.

3) Для каждого basic элемента есть свой метод.

4) Для всех letter элементов есть один метод, принимающий букву. Проверку на соответствие буквы алфавиту можно сделать тут, 
 но это, кажется, не очень хорошая мысль. По сути, этот метод - прослойка над методом tape.

5) Метод для subdiagram меняет значение currentDiagram и currentElement. Их старые значеия помещает куда-то в стек.
  Вообще, так как это связанные значения было бы не плохо ввести какой-то формат хранения этих ребят вместа. Что-то такое
  ```
  {
    "diagram": diagramLink
    "element": elementLink
  }
  ```
  Или в классе Diagram добавить какой-то указатель на текущий объект.

6) Наконец, есть главный метод (типо doStep), ради которого все затевается. Он смотрит на currentElement, в соответствии с ним
 вызывает другой метод, и после выполнения меняет значение currentElement.

7) За перемещение по стеку отвечают subdiagram и exit, но, возможно, это не лучшая мысль раскидывать такой серьезный
 фуекционал по вспомагательным методам. Тогда за перемещение будет отвечать главный метод.
 
 
### Вариант второй
В первом варианте один экземляр одного класса работал со всем "пакетом диаграмм".
Однако можно сделать парня, который будет работать только в рамках одной диаграммы. То есть мы скармливаем ему экземпляр
ленты и диаграмму. Он так же, как и в прошлом варианте вызывает свои внутринние методы для обработки элементов, но
натыкаясь на subdiagram не меняет свое глобальное состояние (currentDiagram), а создает новый экземляр своего класса,
передает ему сабдиаграмму и ленту. Встречая exit он просто умирает, рапортую об успешном завершении. Разумеентся, все равно
где-то снаружи есть стек и прочее. Плюсом является большая гибкость такого решения.
