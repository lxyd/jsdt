Лень рисовать, поэтому объясню так, что за диаграмма файле test_diagram.json.

Первая диаграмма в массиве (элемент с индексом 1) - главная.
В коде это никак не выыделяется, но решением является она.
Задача - найти дополнительный код двоичного числа. Для простоты не убираем впередистоящие нули
и все такое. Просто копировать, потом заменить 0 на 1 и наоборот, прибавить 1.

И так начинаем с нулевого элемента (это всегда "enter"),
смотрим на next. Это массив в котором список id соединителей, по которым мы переходим в зависимости от
ленты. Смотрим на next.[0] там написано l0 значит смотрим на line.l0
Там символы которым удовлетворяет эта стрелка в качестве ключа и id в качестве свойства.
Ключ содержитвесь весь  алфавит, так что переходим на элемент 1.
Дальше расписывать не буду, вроде, мысль ясна.

С помощью машины L переходим на первый пробел перед входными данными.
Машина K копирует слово и оставляет нас перед скопированым словом.
(У Дзюбы так работало, я потому так и написал. Понятно, что не нормировано,
 для кошерности можно вставить L).
Дальше мы машиной r идем вправо и видим
    "0" => пишем "1", возвращаемся на r
    "1" => пишем "0", возвращаемся на r
    " " => слово кончилось, мы получили обратный код.
Теперь вызываем пользовательскую машину plus_one
Как понятно из названия, она должна прибавлять единицу.
Ее я полностью писать не стал, так как ничего нового там не должно быть, машины все равноправные.
После ее выполнения, переходим на "exit" и заканчиваем работу.

