# Основные вопросы хранения данных.

Тут перечисленны варианты хранения данных, плюсы/минусы разных подохов и т.д.
Вероятно, стоит дополнить чем-то еще, новыбрать нужно самое основное.
Большую часть деталей придется решать исходя из этого списка.
Предлагаю решать в предложенном порядке.

## 1) Хранение диаграмм.
а) Хранить список диаграмм в массиве:
```
		{
			...
			"diagrams" : [{...}, {...}, ...]
			...
		}
```

б) Хранить словарем (питоно сленг, ну понятно, в общем)
```
		{
			"diag_name1" : {...}
			"diag_name2" : {...}
		}```
```

В первом случае, плюсом будет фиксиованый порядок диаграмм.
Во втором случае, мы легко получаем диаграмму по имени, но вопрос, нужно ли это.
В целом, варианты взаимозаменяемы, с помощью маневров разной степени костыльности
можно получить один и тот же функционал как в первом, так и во втором варианте.
Поэтому главный критерий - удобность и, возможно, эта самая степень костыльности.


## 2) Как хранить содержимое диаграмм.
а) Хранить все одинаково и в одном месте:
```
		{ //Это не основной блок JSON, а внутренности диаграммы
			0 : {"type": "enter", ...}
			1 : {"type": ...}
			...
		}
```	
				
б) Разбрасывать по типам
```
		{ //Аналогично, не основной блок, а внутренности диаграммы
			"exit" : {
				// id (ключ) начинается с ex чтобы однозначно указывать на тип объекта диаграммы
				//(ex_1 - точно выход, al_1 - alphabit...)
				"ex_1" : {...}
				"ex_2" : {...}
				...
			}
		}

```

Тут нужно выбирать не только более удобный вариант,
так как в отличии от пункта (1) код для работы с разными форматами сильно меняется.
Приведены крайние варианты, возможно, стоит смешать два подхода.

В первом случае, в примере, "enter" является первым (точнее, нулевым)
не случайно. Искать точку входа по сотням id - развлечения для олимпиадников.
Проще захардкодить и ждать, пока пользователь нарисует ее, чтобы дописать остальные данные.

Вероятно, и в первом и во втором случае лучше всего хранить информацию о передыдущем
и слудующем объекте (вернее, их id и условия перехода для следующего).

Важно решить, будут ли выделяться связующие элементы(стрелки).
Думаю, стоит отталкиваться именно от этого.

## 3) Поддержка поддиректорий.
На самом деле, тут все достаточно просто. Если решаем отложить этот вопрос,
то в итоге пути хранятся отдельно от диаграмм. Где-то в корне JSON.
Если сразу пилим поддержку, то можно хранить внутри диаграмм, но сейчас
этот вопрос не главный. Можно держать его в голове, но даже если выберем вариант,
который окажется менее удобным, ничего страшного не произойдет.


# Общие черты.
```
1) У каждого элемента свой id
2) В корне должна быть версия формата
3) ...
```

# Что можно сделать, чтобы найти тот самый долгожданный формат.

Можно отталкиваться от того, как программа(скрипт скорее) пользователя будет выполняться.

```
1. Ищем точку входа.
2. Смотрим на ленту.
3. Переход по стрелке в соответствии с данными на ленте.
	3.1. Определить id нужной стрелки
	3.2. По id получить объект(подобъект, ну понятно, короче, саму стрелку)
	3.2. Получить id слудующей диаграммы
	3.3. По id получить объект(подобъект, саму диаграмму)
	3.4. Сделать магию
4) Возвращаемся к 2)
```

В этом варианте стрелка - равноправный объект. Но это только один из возможных.
Если разработать алгоритм, то вопрос о хранении данных станет гораздо прозрачнее.


